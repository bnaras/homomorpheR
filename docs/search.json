[{"path":"/articles/DHCox.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"short way toy MLE example useful example using Cox regression. first, need survival package homomopheR package. generate simulated data purpose example. three sites patient data (sizes 1000, 500 1500) respectively, containing sex (0, 1) male/female age 40 70 biomarker bm time event interest indicator event 1 event observed 0 otherwise. common fit stratified models using sites strata since patient characteristics usually differ site site. baseline hazards (lambdaT) different site share common coefficients (beta.1, beta.2 beta.3 age, sex bm respy.) model. See (Terry M. Therneau Patricia M. Grambsch 2000) Therneau Grambsch details. model site ii S(t,age,sex,bm)=[S0i(t)]exp⁡(β1age+β2sex+β3bm) S(t, age, sex, bm) = [S_0^(t)]^{\\exp(\\beta_1 age + \\beta_2 sex + \\beta_3 bm)} summary data three sites.","code":"if (!require(\"survival\")) {     stop(\"this vignette requires the survival package\") } library(homomorpheR) sampleSize <- c(n1 = 1000, n2 = 500, n3 = 1500)  set.seed(12345)  beta.1 <- -.015; beta.2 <- .2; beta.3 <- .001;  lambdaT <- c(5, 4, 3) lambdaC <- 2  coxData <- lapply(seq_along(sampleSize),                   function(i) {                       sex <- sample(c(0, 1), size = sampleSize[i], replace = TRUE)                       age <- sample(40:70, size = sampleSize[i], replace = TRUE)                       bm <- rnorm(sampleSize[i])                       trueTime <- rweibull(sampleSize[i],                                            shape = 1,                                            scale = lambdaT[i] * exp(beta.1 * age + beta.2 * sex + beta.3 * bm ))                       censoringTime <- rweibull(sampleSize[i],                                                 shape = 1,                                                 scale = lambdaC)                       time <- pmin(trueTime, censoringTime)                       event <- (time == trueTime)                       data.frame(stratum = i,                                  sex = sex,                                  age = age,                                  bm = bm,                                  time = time,                                  event = event)                   })"},{"path":"/articles/DHCox.html","id":"site-1","dir":"Articles","previous_headings":"Introduction","what":"Site 1","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"","code":"str(coxData[[1]]) ## 'data.frame':    1000 obs. of  6 variables: ##  $ stratum: int  1 1 1 1 1 1 1 1 1 1 ... ##  $ sex    : num  1 0 1 1 1 1 1 0 0 1 ... ##  $ age    : int  47 69 70 47 41 51 59 45 43 69 ... ##  $ bm     : num  -0.516 -1.375 1.01 0.454 0.275 ... ##  $ time   : num  1.37 0.95 2.35 2.48 1.93 ... ##  $ event  : logi  FALSE TRUE TRUE TRUE FALSE FALSE ..."},{"path":"/articles/DHCox.html","id":"site-2","dir":"Articles","previous_headings":"Introduction","what":"Site 2","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"","code":"str(coxData[[2]]) ## 'data.frame':    500 obs. of  6 variables: ##  $ stratum: int  2 2 2 2 2 2 2 2 2 2 ... ##  $ sex    : num  0 1 0 1 1 1 0 1 1 1 ... ##  $ age    : int  54 63 53 70 40 57 48 54 63 47 ... ##  $ bm     : num  -0.3243 0.2531 0.0464 0.8149 -0.1921 ... ##  $ time   : num  1.10483 0.34804 0.01602 0.68249 0.00157 ... ##  $ event  : logi  FALSE FALSE TRUE TRUE FALSE TRUE ..."},{"path":"/articles/DHCox.html","id":"site-3","dir":"Articles","previous_headings":"Introduction","what":"Site 3","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"","code":"str(coxData[[3]]) ## 'data.frame':    1500 obs. of  6 variables: ##  $ stratum: int  3 3 3 3 3 3 3 3 3 3 ... ##  $ sex    : num  1 0 0 1 1 1 0 1 0 1 ... ##  $ age    : int  55 70 49 60 44 42 58 62 61 68 ... ##  $ bm     : num  -0.9554 0.8138 0.0425 -1.2272 0.3244 ... ##  $ time   : num  0.0733 1.9869 2.2946 0.1231 1.0602 ... ##  $ event  : logi  TRUE FALSE FALSE TRUE FALSE FALSE ..."},{"path":[]},{"path":"/articles/DHCox.html","id":"aggregated-fit","dir":"Articles","previous_headings":"","what":"Aggregated fit","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"data aggregated one place, simple fit model. , row-bind data three sites. age sex significant, bm . estimates β̂\\hat{\\beta} (-0.180, .020, .007). can also print value (partial) log-likelihood MLE. first value parameter value (0, 0, 0) last value MLE.","code":"aggModel <- coxph(formula = Surv(time, event) ~ sex +                                 age + bm + strata(stratum),                             data = do.call(rbind, coxData)) aggModel ## Call: ## coxph(formula = Surv(time, event) ~ sex + age + bm + strata(stratum),  ##     data = do.call(rbind, coxData)) ##  ##          coef exp(coef)  se(coef)      z       p ## sex -0.160493  0.851723  0.050627 -3.170 0.00152 ## age  0.010057  1.010108  0.002835  3.547 0.00039 ## bm  -0.005989  0.994029  0.025208 -0.238 0.81222 ##  ## Likelihood ratio test=22.82  on 3 df, p=4.413e-05 ## n= 3000, number of events= 1575 aggModel$loglik ## [1] -9534.495 -9523.087"},{"path":"/articles/DHCox.html","id":"distributed-computation","dir":"Articles","previous_headings":"Aggregated fit","what":"Distributed Computation","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"Assume now data coxData distributed three sites none want share actual data among even master computation process. wish keep data secret willing, together, provide sum local negative log-likelihoods. need way master process able associate contribution likelihood site. overall likelihood function l(λ)l(\\lambda) entire data therefore sum likelihoods site: l(λ)=l1(λ)+l2(λ)+l3(λ).l(\\lambda) = l_1(\\lambda)+l_2(\\lambda)+l_3(\\lambda). can likelihood computed maintaining privacy? Assuming every site including master access homomorphic computation library homomorpheR, likelihood can computed privacy-preserving manner using following scheme. use E(x)E(x) D(x)D(x) denote encrypted decrypted values xx respectively. Master generates public/private key pair. Master distributes public key sites. (private key distributed kept master.) Master generates random offset rr obfuscate intial likelihood. Master sends E(r)E(r) guess λ0\\lambda_0 site 1. Note λ\\lambda encrypted. Site 1 computes l1=l(λ0,y1)l_1 = l(\\lambda_0, y_1), local likelihood local data y1y_1 using parameter λ0\\lambda_0. sends λ0\\lambda_0 E(r)+E(l1)E(r) + E(l_1) site 2. Site 2 computes l2=l(λ0,y2)l_2 = l(\\lambda_0, y_2), local likelihood local data y2y_2 using parameter λ0\\lambda_0. sends λ0\\lambda_0 E(r)+E(l1)+E(l2)E(r) + E(l_1) + E(l_2) site 3. Site 3 computes l3=l(λ0,y3)l_3 = l(\\lambda_0, y_3), local likelihood local data y3y_3 using parameter λ0\\lambda_0. sends E(r)+E(l1)+E(l2)+E(l3)E(r) + E(l_1) + E(l_2) + E(l_3) back master. Master retrieves E(r)+E(l1)+E(l2)+E(l3)E(r) + E(l_1) + E(l_2) + E(l_3) , due homomorphism, exactly E(r+l1+l2+l3)=E(r+l).E(r+l_1+l_2+l_3) = E(r+l). master computes D(E(r+l))−rD(E(r+l)) - r obtain value overall likelihood λ0\\lambda_0. Master updates λ0\\lambda_0 new guess λ1\\lambda_1 repeats steps 1-5. process iterated convergence. added security, even steps 0-5 can repeated, additional computational cost. pictorially shown .","code":""},{"path":"/articles/DHCox.html","id":"implementation","dir":"Articles","previous_headings":"Aggregated fit","what":"Implementation","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"implementation assumes encryption decryption can happen real numbers actual situation. Instead, use rational approximations using large denominator, 22562^{256}, say. future, course, need build actual library built rigorous algorithms guaranteeing precision overflow/undeflow detection. now, just ad hoc implementation. Also, since using homomorphic additive properties, partial homomorphic scheme Paillier Encryption system sufficient computations. define class encapsulate sites compute Poisson likelihood site data given parameter λ\\lambda. Note addNLLAndForward method takes care split result integer fractional part performing arithmetic operations. (latter approximated rational number.) define class encapsulate sites compute partial log likelihood site data given parameter β\\beta. code , exploit, expository purposes, feature coxph: control parameter can passed evaluate partial likelihood given β\\beta value. now ready use sites computation.","code":"Site <- R6::R6Class(\"Site\",                     private = list(                         ## name of the site                         name = NA,                         ## only master has this, NA for workers                         privkey = NA,                         ## local data                         data = NA,                         ## The next site in the communication: NA for master                         nextSite = NA,                         ## is this the master site?                         iAmMaster = FALSE,                         ## intermediate result variable                         intermediateResult = NA,                         ## Control variable for cox regression                         cph.control = NA                     ),                     public = list(                         count = NA,                         ## Common denominator for approximate real arithmetic                         den = NA,                         ## The public key; everyone has this                         pubkey = NA,                         initialize = function(name, data, den) {                             private$name <- name                             private$data <- data                             self$den <- den                             private$cph.control <- replace(coxph.control(), \"iter.max\", 0)                         },                         setPublicKey = function(pubkey) {                             self$pubkey <- pubkey                         },                         setPrivateKey = function(privkey) {                             private$privkey <- privkey                         },                         ## Make me master                         makeMeMaster = function() {                             private$iAmMaster <- TRUE                         },                         ## add neg log lik and forward to next site                         addNLLAndForward = function(beta, enc.offset) {                             if (private$iAmMaster) {                                 ## We are master, so don't forward                                 ## Just store intermediate result and return                                 private$intermediateResult <- enc.offset                             } else {                                 ## We are workers, so add and forward                                 ## add negative log likelihood and forward result to next site                                 ## Note that offset is encrypted                                 nllValue <- self$nLL(beta)                                 result.int <- floor(nllValue)                                 result.frac <- nllValue - result.int                                 result.fracnum <- gmp::as.bigq(gmp::numerator(gmp::as.bigq(result.frac) * self$den))                                 pubkey <- self$pubkey                                 enc.result.int <- pubkey$encrypt(result.int)                                 enc.result.fracnum <- pubkey$encrypt(result.fracnum)                                 result <- list(int = pubkey$add(enc.result.int, enc.offset$int),                                                frac = pubkey$add(enc.result.fracnum, enc.offset$frac))                                 private$nextSite$addNLLAndForward(beta, enc.offset = result)                             }                             ## Return a TRUE result for now.                             TRUE                         },                         ## Set the next site in the communication graph                         setNextSite = function(nextSite) {                             private$nextSite <- nextSite                         },                         ## The negative log likelihood                             nLL = function(beta) {                             if (private$iAmMaster) {                                 ## We're master, so need to get result from sites                                 ## 1. Generate a random offset and encrypt it                                 pubkey <- self$pubkey                                 offset <- list(int = random.bigz(nBits = 256),                                                frac = random.bigz(nBits = 256))                                 enc.offset <- list(int = pubkey$encrypt(offset$int),                                                    frac = pubkey$encrypt(offset$frac))                                 ## 2. Send off to next site                                 throwaway <- private$nextSite$addNLLAndForward(beta, enc.offset)                                 ## 3. When the call returns, the result will be in                                 ##    the field intermediateResult, so decrypt that.                                 sum <- private$intermediateResult                                 privkey <- private$privkey                                 intResult <- as.double(privkey$decrypt(sum$int) - offset$int)                                 fracResult <- as.double(gmp::as.bigq(privkey$decrypt(sum$frac) - offset$frac) / den)                                 intResult + fracResult                             } else {                                 ## We're worker, so compute local negative log likelihood                                 tryCatch({                                     m <- coxph(formula = Surv(time, event) ~ sex + age + bm,                                                          data = private$data,                                                          init = beta,                                                          control = private$cph.control)                                     -(m$loglik[1])                                 },                                 error = function(e) NA)                             }                         })                     )"},{"path":"/articles/DHCox.html","id":"generate-public-and-private-key-pair","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"1. Generate public and private key pair","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"also choose denominator rational approximations.","code":"keys <- PaillierKeyPair$new(1024) ## Generate new public and private key. den <- gmp::as.bigq(2)^256  #Our denominator for rational approximations"},{"path":"/articles/DHCox.html","id":"create-sites","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"2. Create sites","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"master process also site data. thus designated.","code":"site1 <- Site$new(name = \"Site 1\", data = coxData[[1]], den = den) site2 <- Site$new(name = \"Site 2\", data = coxData[[2]], den = den) site3 <- Site$new(name = \"Site 3\", data = coxData[[3]], den = den) ## Master has no data! master <- Site$new(name = \"Master\", data = c(), den = den) master$makeMeMaster()"},{"path":"/articles/DHCox.html","id":"distribute-public-key-to-sites","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"2. Distribute public key to sites","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"master private key decryption.","code":"site1$setPublicKey(keys$pubkey) site2$setPublicKey(keys$pubkey) site3$setPublicKey(keys$pubkey) master$setPublicKey(keys$pubkey) master$setPrivateKey(keys$getPrivateKey())"},{"path":"/articles/DHCox.html","id":"define-the-communication-graph","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"3. Define the communication graph","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"Master always send first site, others forward results turn last site returning master.","code":"master$setNextSite(site1) site1$setNextSite(site2) site2$setNextSite(site3) site3$setNextSite(master)"},{"path":"/articles/DHCox.html","id":"perform-the-likelihood-estimation","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"4. Perform the likelihood estimation","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"","code":"library(stats4) nll <- function(age, sex, bm) master$nLL(c(age, sex, bm)) fit <- mle(nll, start = list(age = 0, sex = 0, bm = 0))"},{"path":"/articles/DHCox.html","id":"compare-the-results","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"5. Compare the results","title":"Distributed Stratified Cox Regression using Homomorphic Computation","text":"summary show results. Note estimated coefficients standard errors closely match full model summary . log likelihood distributed homomorphic fit also matches model aggregated data:","code":"summary(fit) ## Maximum likelihood estimation ##  ## Call: ## mle(minuslogl = nll, start = list(age = 0, sex = 0, bm = 0)) ##  ## Coefficients: ##         Estimate  Std. Error ## age -0.160493329 0.050626611 ## sex  0.010057265 0.002835374 ## bm  -0.005988214 0.025208370 ##  ## -2 log L: 19046.17 summary(aggModel) ## Call: ## coxph(formula = Surv(time, event) ~ sex + age + bm + strata(stratum),  ##     data = do.call(rbind, coxData)) ##  ##   n= 3000, number of events= 1575  ##  ##          coef exp(coef)  se(coef)      z Pr(>|z|)     ## sex -0.160493  0.851723  0.050627 -3.170  0.00152 **  ## age  0.010057  1.010108  0.002835  3.547  0.00039 *** ## bm  -0.005989  0.994029  0.025208 -0.238  0.81222     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ##     exp(coef) exp(-coef) lower .95 upper .95 ## sex    0.8517      1.174    0.7713    0.9406 ## age    1.0101      0.990    1.0045    1.0157 ## bm     0.9940      1.006    0.9461    1.0444 ##  ## Concordance= 0.536  (se = 0.009 ) ## Likelihood ratio test= 22.82  on 3 df,   p=4e-05 ## Wald test            = 22.81  on 3 df,   p=4e-05 ## Score (logrank) test = 22.85  on 3 df,   p=4e-05 cat(sprintf(\"logLik(MLE fit): %f, logLik(Agg. fit): %f.\\n\", logLik(fit), aggModel$loglik[2])) ## logLik(MLE fit): -9523.087001, logLik(Agg. fit): -9523.087001."},{"path":[]},{"path":"/articles/DHCoxNCP.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"short way toy MLE example useful example using Cox regression. first, need survival package homomopheR package. generate simulated data purpose example. three sites patient data (sizes 1000, 500 1500) respectively, containing sex (0, 1) male/female age 40 70 biomarker bm time event interest indicator event 1 event observed 0 otherwise. common fit stratified models using sites strata since patient characteristics usually differ site site. baseline hazards (lambdaT) different site share common coefficients (beta.1, beta.2 beta.3 age, sex bm respy.) model. See (Terry M. Therneau Patricia M. Grambsch 2000) Therneau Grambsch details. model site ii S(t,age,sex,bm)=[S0i(t)]exp⁡(β1age+β2sex+β3bm) S(t, age, sex, bm) = [S_0^(t)]^{\\exp(\\beta_1 age + \\beta_2 sex + \\beta_3 bm)} summary data three sites.","code":"if (!require(\"survival\") || !requireNamespace(\"digest\", quietly = TRUE)) {     stop(\"this vignette requires both the survival & digest package\") } library(homomorpheR) sampleSize <- c(n1 = 1000, n2 = 500, n3 = 1500)  set.seed(12345)  beta.1 <- -.015; beta.2 <- .2; beta.3 <- .001;  lambdaT <- c(5, 4, 3) lambdaC <- 2  coxData <- lapply(seq_along(sampleSize),                   function(i) {                       sex <- sample(c(0, 1), size = sampleSize[i], replace = TRUE)                       age <- sample(40:70, size = sampleSize[i], replace = TRUE)                       bm <- rnorm(sampleSize[i])                       trueTime <- rweibull(sampleSize[i],                                            shape = 1,                                            scale = lambdaT[i] * exp(beta.1 * age + beta.2 * sex + beta.3 * bm ))                       censoringTime <- rweibull(sampleSize[i],                                                 shape = 1,                                                 scale = lambdaC)                       time <- pmin(trueTime, censoringTime)                       event <- (time == trueTime)                       data.frame(stratum = i,                                  sex = sex,                                  age = age,                                  bm = bm,                                  time = time,                                  event = event)                   })"},{"path":"/articles/DHCoxNCP.html","id":"site-1","dir":"Articles","previous_headings":"Introduction","what":"Site 1","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"","code":"str(coxData[[1]]) ## 'data.frame':    1000 obs. of  6 variables: ##  $ stratum: int  1 1 1 1 1 1 1 1 1 1 ... ##  $ sex    : num  1 0 1 1 1 1 1 0 0 1 ... ##  $ age    : int  47 69 70 47 41 51 59 45 43 69 ... ##  $ bm     : num  -0.516 -1.375 1.01 0.454 0.275 ... ##  $ time   : num  1.37 0.95 2.35 2.48 1.93 ... ##  $ event  : logi  FALSE TRUE TRUE TRUE FALSE FALSE ..."},{"path":"/articles/DHCoxNCP.html","id":"site-2","dir":"Articles","previous_headings":"Introduction","what":"Site 2","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"","code":"str(coxData[[2]]) ## 'data.frame':    500 obs. of  6 variables: ##  $ stratum: int  2 2 2 2 2 2 2 2 2 2 ... ##  $ sex    : num  0 1 0 1 1 1 0 1 1 1 ... ##  $ age    : int  54 63 53 70 40 57 48 54 63 47 ... ##  $ bm     : num  -0.3243 0.2531 0.0464 0.8149 -0.1921 ... ##  $ time   : num  1.10483 0.34804 0.01602 0.68249 0.00157 ... ##  $ event  : logi  FALSE FALSE TRUE TRUE FALSE TRUE ..."},{"path":"/articles/DHCoxNCP.html","id":"site-3","dir":"Articles","previous_headings":"Introduction","what":"Site 3","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"","code":"str(coxData[[3]]) ## 'data.frame':    1500 obs. of  6 variables: ##  $ stratum: int  3 3 3 3 3 3 3 3 3 3 ... ##  $ sex    : num  1 0 0 1 1 1 0 1 0 1 ... ##  $ age    : int  55 70 49 60 44 42 58 62 61 68 ... ##  $ bm     : num  -0.9554 0.8138 0.0425 -1.2272 0.3244 ... ##  $ time   : num  0.0733 1.9869 2.2946 0.1231 1.0602 ... ##  $ event  : logi  TRUE FALSE FALSE TRUE FALSE FALSE ..."},{"path":[]},{"path":"/articles/DHCoxNCP.html","id":"aggregated-fit","dir":"Articles","previous_headings":"","what":"Aggregated fit","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"data aggregated one place, simple fit model. , row-bind data three sites. age sex significant, bm . estimates β̂\\hat{\\beta} (-0.180, .020, .007). can also print value (partial) log-likelihood MLE. first value initial parameter value (0, 0, 0) second value MLE.","code":"aggModel <- coxph(formula = Surv(time, event) ~ sex +                                 age + bm + strata(stratum),                             data = do.call(rbind, coxData)) aggModel ## Call: ## coxph(formula = Surv(time, event) ~ sex + age + bm + strata(stratum),  ##     data = do.call(rbind, coxData)) ##  ##          coef exp(coef)  se(coef)      z       p ## sex -0.160493  0.851723  0.050627 -3.170 0.00152 ## age  0.010057  1.010108  0.002835  3.547 0.00039 ## bm  -0.005989  0.994029  0.025208 -0.238 0.81222 ##  ## Likelihood ratio test=22.82  on 3 df, p=4.413e-05 ## n= 3000, number of events= 1575 aggModel$loglik ## [1] -9534.495 -9523.087"},{"path":"/articles/DHCoxNCP.html","id":"distributed-computation","dir":"Articles","previous_headings":"Aggregated fit","what":"Distributed Computation","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"Assume now data coxData distributed three sites none want share actual data among even master computation process. wish keep data secret willing, together, provide sum local negative log-likelihoods. wish manner master process unable associate contribution likelihood site. overall likelihood function l(β)l(\\beta) entire data sum likelihoods site: l(β)=l1(β)+l2(β)+l3(β).l(\\beta) = l_1(\\beta)+l_2(\\beta)+l_3(\\beta). can likelihood computed preventing master knowing individual contributions site? key ensuring site reveal actual value li(β)l_i(\\beta) β\\beta involves use two non-cooperating parties, say, NCP1 NCP2. Site ii sends E(li(β)+ri)E(l_i(\\beta) + r_i) NCP1 E(li(β)−ri)E(l_i(\\beta) - r_i) NCP2, E(x)E(x) denotes encrypted value xx rir_i random quantity generated anew site β\\beta. NCP1 can compute ∑=13E(li+ri)\\sum_{=1}^3E(l_i + r_i) NCP2 can compute ∑=13E(li−ri)\\sum_{=1}^3E(l_i - r_i), individually, neither handle l=∑=13lil = \\sum_{=1}^3 l_i. master process can retrieve ∑=13E(li+ri)\\sum_{=1}^3E(l_i + r_i) ∑=13E(li−ri)\\sum_{=1}^3E(l_i - r_i) NCP1 NCP2 respectively. encrypted value sum likelihood contributions sites, obfuscated random term, hence random master. However, master using associative homomorphic properties E(.)E(.), can compute: ∑=13E(li+ri)+∑=13E(li−ri)=∑=13E(li+ri+li−ri)=∑=13E(2li)=E(2l) \\sum_{=1}^3E(l_i + r_i) +\\sum_{=1}^3E(l_i - r_i) = \\sum_{=1}^3E(l_i + r_i + l_i - r_i)  = \\sum_{=1}^3E(2l_i)  = E(2l) since l=l1+l2+l3l = l_1 + l_2 + l_3. master can now decrypt result obtain 2l2l! pictorially shown . red arrows show master proposing value β\\beta sites, reply back NCP1 NCP2. master retrieves values NCP1 NCP2 sums .","code":""},{"path":"/articles/DHCoxNCP.html","id":"a-modified-topology","dir":"Articles","previous_headings":"Aggregated fit > Distributed Computation","what":"A Modified Topology","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"drawback scheme channels communication established site master process also two non-cooperating parties NCP1 NCP2. number participating sites computation changes, master NCP1 NCP2 made aware change. simpler NCP1 NCP2 can talk master sites. situation arise, example, sites participating disease specific registry. parties NCP1 NCP2 probably set new site onboarded needs known P1 P2. added advantage hiding number sites, even 1! communication topology mean β\\beta values funneled sites NCP1 NCP2 can easily accomplished. picture shows configuration looks complicated actually . summarize, modified scheme several characteristics: master communicates NCP1 NCP2 NCP1 NCP2 parties communicating master sites NCP1 NCP2 ones know many sites participating New sites can added NCP1 NCP2 need account master remains oblivous number sites; scheme works even one site appears unnecessary communication information, .e. β\\beta sent twice site NCP1 NCP2. easily mitigated engineering either using broker NCP1 NCP2, sites caching results short period avoid recomputation.","code":""},{"path":"/articles/DHCoxNCP.html","id":"implementation","dir":"Articles","previous_headings":"Aggregated fit","what":"Implementation","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"implementation assumes encryption decryption can happen real numbers actual situation. Instead, use rational approximations using large denominator, 22562^{256}, say. future, course, need build actual library built rigorous algorithms guaranteeing precision overflow/undeflow detection. now, just ad hoc implementation. Also, since using homomorphic additive properties, partial homomorphic scheme Paillier Encryption system sufficient computations. define classes encapsulate sites, non-cooperating parties master process.","code":""},{"path":"/articles/DHCoxNCP.html","id":"the-site-class","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"The Site Class","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"site class compute partial log likelihood site data given parameter β\\beta. Note private nll method takes care split result integer fractional part performing arithmetic operations. (latter approximated rational number.) code , exploit feature coxph: control parameter can passed evaluate partial likelihood given β\\beta value. also use cache can distribute piece encrypted likelihood E(li−ri)E(l_i - r_i) E(li+ri)E(l_i + r_i) two non-cooperating parties.","code":"Site <-     R6::R6Class(             \"Site\",             private = list(                 ## name of the site                 name = NA,                 ## local data                 data = NA,                 ## Control variable for cox regression                 cph.control = NA,                 beta_cache = list(),                 local_nll = function(beta) {                     ## Check if value is cached                     beta_hash  <- paste0(\"b\", digest::digest(beta, algo = \"xxhash64\"))                     result  <- private$beta_cache[[beta_hash]]                     if (is.null(result)) {                         ## We're worker, so compute local negative log likelihood                         nllValue  <- tryCatch({                             m <- coxph(formula = Surv(time, event) ~ sex + age + bm,                                        data = private$data,                                        init = beta,                                        control = private$cph.control)                             -(m$loglik[1])                         },                         error = function(e) NA)                         if (!is.na(nllValue)) {                             pubkey <- self$pubkey                             ## Generate random offset for int and frac parts                             offset <- list(int = random.bigz(nBits = 256),                                            frac = random.bigz(nBits = 256))                             ## 2. Add to neg log likelihood                             result.int <- floor(nllValue)                             result.frac <- nllValue - result.int                             ## Approximate fractional part by a rational                             result.fracnum <- gmp::as.bigz(gmp::numerator(gmp::as.bigq(result.frac) * self$den))                             result  <- list(                                 int1 = pubkey$encrypt(result.int - offset$int),                                 frac1 = pubkey$encrypt(result.fracnum - offset$frac),                                 int2 = pubkey$encrypt(result.int + offset$int),                                 frac2 = pubkey$encrypt(result.fracnum + offset$frac)                             )                             private$beta_cache[[beta_hash]]  <- result                         } else {                             result  <- list(int1 = NA, frac1 = NA, int2 = NA, frac2 = NA)                         }                     }                     result                 }             ),             public = list(                 count = NA,                 ## Common denominator for approximate real arithmetic                 den = NA,                 ## The master's public key; everyone has this                 pubkey = NA,                 initialize = function(name, data) {                     private$name <- name                     private$data <- data                     private$cph.control <- replace(coxph.control(), \"iter.max\", 0)                 },                 setPublicKey = function(pubkey) {                     self$pubkey <- pubkey                 },                 setDenominator = function(den) {                     self$den = den                 },                 ## neg log lik,                 nll = function(beta, party) {                     result  <- private$local_nll(beta)                     if (party == 1) {                         list(int = result$int1, frac = result$frac1)                     } else {                         list(int = result$int2, frac = result$frac2)                     }                 }             )         )"},{"path":"/articles/DHCoxNCP.html","id":"the-non-cooperating-parties-class","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"The Non-cooperating Parties Class","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"non-cooperating parties can communicate sites. methods adding sites, passing public keys master etc. nll method class merely calls site compute result adds sending master, master idea individual contributions.","code":"NCParty <-     R6::R6Class(             \"NCParty\",             private = list(                 ## name of the site                 name = NA,                 ## NC party number                 number = NA,                 ## The master                 master = NA,                 ## The sites                 sites = list()             ),             public = list(                 ## The master's public key; everyone has this                 pubkey = NA,                 ## The denoinator for rational arithmetic                 den = NA,                 initialize = function(name, number) {                     private$name <- name                     private$number  <- number                 },                 setPublicKey = function(pubkey) {                     self$pubkey <- pubkey                     ## Propagate to sites                     for (site in sites) {                         site$setPublicKey(pubkey)                     }                 },                 setDenominator = function(den) {                     self$den <- den                     ## Propagate to sites                     for (site in sites) {                         site$setDenominator(den)                     }                 },                 addSite = function(site) {                     private$sites  <- c(private$sites, list(site))                 },                 ## neg log lik                 nll = function(beta) {                     pubkey  <- self$pubkey                     results  <- lapply(sites, function(x) x$nll(beta, private$number))                     ## Accumulate the integer and fractional parts                     n  <- length(results)                     sumInt  <- results[[1L]]$int                     sumFrac <- results[[1L]]$frac                     for (i in 2:n) {                         sumInt  <- pubkey$add(sumInt, results[[i]]$int)                         sumFrac  <- pubkey$add(sumFrac, results[[i]]$frac)                     }                     list(int = sumInt, frac = sumFrac)                 }             )         )"},{"path":"/articles/DHCoxNCP.html","id":"the-master-class","dir":"Articles","previous_headings":"Aggregated fit > Implementation","what":"The Master Class","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"master process","code":"Master  <-     R6::R6Class(             \"Master\",             private = list(                 ## name of the site                 name = NA,                 ## Private and public keys                 keys = NA,                 ## Non cooperating party 1                 nc_party_1 = NA,                 ## Non cooperating party 2                 nc_party_2 = NA             ),             public = list(                 ## Denominator for rational arithmetic                 den  = NA,                 initialize = function(name) {                     private$name <- name                     private$keys <- PaillierKeyPair$new(1024) ## Generate new public and private key.                     self$den <- gmp::as.bigq(2)^256  #Our denominator for rational approximations                 },                 setNCParty1  = function(site) {                     private$nc_party_1 <- site                     private$nc_party_1$setPublicKey(private$keys$pubkey)                     private$nc_party_1$setDenominator(self$den)                 },                 setNCParty2  = function(site) {                     private$nc_party_2 <- site                     private$nc_party_2$setPublicKey(private$keys$pubkey)                     private$nc_party_2$setDenominator(self$den)                 },                 ## neg log lik                 nLL = function(beta) {                     pubkey  <- private$keys$pubkey                     privkey  <- private$keys$getPrivateKey()                     result1  <- private$nc_party_1$nll(beta)                     result2  <- private$nc_party_2$nll(beta)                     ## Accumulate the integer and fractional parts                     sumInt  <- pubkey$add(result1$int, result2$int)                     sumFrac  <- pubkey$add(result1$frac, result2$frac)                     intResult <- as.double(privkey$decrypt(sumInt))                     fracResult <- as.double(gmp::as.bigq(privkey$decrypt(sumFrac)) / self$den)                     ## Since we 2L, we divide by 2.                     (intResult + fracResult) / 2.0                 }             )         )"},{"path":"/articles/DHCoxNCP.html","id":"example","dir":"Articles","previous_headings":"Aggregated fit","what":"Example","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"now ready use sites computation.","code":""},{"path":"/articles/DHCoxNCP.html","id":"create-sites","dir":"Articles","previous_headings":"Aggregated fit > Example","what":"1. Create sites","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"","code":"site1 <- Site$new(name = \"Site 1\", data = coxData[[1]]) site2 <- Site$new(name = \"Site 2\", data = coxData[[2]]) site3 <- Site$new(name = \"Site 3\", data = coxData[[3]])  sites  <- list(site1 = site1, site2 = site2, site3 = site3)"},{"path":"/articles/DHCoxNCP.html","id":"create-non-cooperating-parties","dir":"Articles","previous_headings":"Aggregated fit > Example","what":"2. Create Non-cooperating parties","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"add sites non-cooperating parties.","code":"ncp1  <- NCParty$new(\"NCP1\", 1) ncp2  <- NCParty$new(\"NCP1\", 2) for (s in sites) {     ncp1$addSite(s)     ncp2$addSite(s) }"},{"path":"/articles/DHCoxNCP.html","id":"create-the-master-process","dir":"Articles","previous_headings":"Aggregated fit > Example","what":"3. Create the master process","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"next connect master non-cooperating parties. point communication graph defined master non-cooperating parties non-cooperating parties sites.","code":"master  <- Master$new(\"Master\") master$setNCParty1(ncp1) master$setNCParty2(ncp2)"},{"path":"/articles/DHCoxNCP.html","id":"perform-the-likelihood-estimation","dir":"Articles","previous_headings":"Aggregated fit > Example","what":"4. Perform the likelihood estimation","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"","code":"library(stats4) nll <- function(age, sex, bm) master$nLL(c(age, sex, bm)) fit <- mle(nll, start = list(age = 0, sex = 0, bm = 0))"},{"path":"/articles/DHCoxNCP.html","id":"compare-the-results","dir":"Articles","previous_headings":"Aggregated fit > Example","what":"5. Compare the results","title":"Distributed Stratified Cox Regression using Non-Cooperating Parties","text":"summary show results. Note estimated coefficients standard errors closely match full model summary . log likelihood distributed homomorphic fit also matches model aggregated data:","code":"summary(fit) ## Maximum likelihood estimation ##  ## Call: ## mle(minuslogl = nll, start = list(age = 0, sex = 0, bm = 0)) ##  ## Coefficients: ##         Estimate  Std. Error ## age -0.160493329 0.050626611 ## sex  0.010057265 0.002835374 ## bm  -0.005988214 0.025208370 ##  ## -2 log L: 19046.17 summary(aggModel) ## Call: ## coxph(formula = Surv(time, event) ~ sex + age + bm + strata(stratum),  ##     data = do.call(rbind, coxData)) ##  ##   n= 3000, number of events= 1575  ##  ##          coef exp(coef)  se(coef)      z Pr(>|z|)     ## sex -0.160493  0.851723  0.050627 -3.170  0.00152 **  ## age  0.010057  1.010108  0.002835  3.547  0.00039 *** ## bm  -0.005989  0.994029  0.025208 -0.238  0.81222     ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ##     exp(coef) exp(-coef) lower .95 upper .95 ## sex    0.8517      1.174    0.7713    0.9406 ## age    1.0101      0.990    1.0045    1.0157 ## bm     0.9940      1.006    0.9461    1.0444 ##  ## Concordance= 0.536  (se = 0.009 ) ## Likelihood ratio test= 22.82  on 3 df,   p=4e-05 ## Wald test            = 22.81  on 3 df,   p=4e-05 ## Score (logrank) test = 22.85  on 3 df,   p=4e-05 cat(sprintf(\"logLik(MLE fit): %f, logLik(Agg. fit): %f.\\n\", logLik(fit), aggModel$loglik[2])) ## logLik(MLE fit): -9523.087001, logLik(Agg. fit): -9523.087001."},{"path":[]},{"path":"/articles/QueryNCP.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Distributed Query Count using Non-Cooperating Parties","text":"demonstrate use non-cooperating parties run distributed query count computation using homomorpheR package simulated data set containing: sex (F, M) female/male age 40 70 bm biomarker","code":"set.seed(130) sample_size  <- c(60, 15, 25) query_data  <- local({     tmp  <- c(0, cumsum(sample_size))     start  <- tmp[1:3] + 1     end  <- tmp[-1]     id_list  <- Map(seq, from = start, to = end)     lapply(seq_along(sample_size),            function(i) {                id  <- sprintf(\"P%4d\", id_list[[i]])                sex <- sample(c(\"F\", \"M\"), size = sample_size[i], replace = TRUE)                age <- sample(40:70, size = sample_size[i], replace = TRUE)                bm <- rnorm(sample_size[i])                data.frame(id = id, sex = sex, age = age, bm = bm, stringsAsFactors = FALSE)            }) })"},{"path":"/articles/QueryNCP.html","id":"site-1","dir":"Articles","previous_headings":"Introduction","what":"Site 1","title":"Distributed Query Count using Non-Cooperating Parties","text":"","code":"str(query_data[[1]]) ## 'data.frame':    60 obs. of  4 variables: ##  $ id : chr  \"P   1\" \"P   2\" \"P   3\" \"P   4\" ... ##  $ sex: chr  \"F\" \"F\" \"F\" \"M\" ... ##  $ age: int  43 67 66 59 63 52 55 46 43 60 ... ##  $ bm : num  1.252 -1.01 0.551 -0.379 0.284 ..."},{"path":"/articles/QueryNCP.html","id":"site-2","dir":"Articles","previous_headings":"Introduction","what":"Site 2","title":"Distributed Query Count using Non-Cooperating Parties","text":"","code":"str(query_data[[2]]) ## 'data.frame':    15 obs. of  4 variables: ##  $ id : chr  \"P  61\" \"P  62\" \"P  63\" \"P  64\" ... ##  $ sex: chr  \"M\" \"F\" \"M\" \"F\" ... ##  $ age: int  53 64 45 61 55 65 65 51 53 47 ... ##  $ bm : num  0.698 -0.447 -0.224 1.086 1.188 ..."},{"path":"/articles/QueryNCP.html","id":"site-3","dir":"Articles","previous_headings":"Introduction","what":"Site 3","title":"Distributed Query Count using Non-Cooperating Parties","text":"","code":"str(query_data[[3]]) ## 'data.frame':    25 obs. of  4 variables: ##  $ id : chr  \"P  76\" \"P  77\" \"P  78\" \"P  79\" ... ##  $ sex: chr  \"M\" \"M\" \"M\" \"M\" ... ##  $ age: int  69 70 41 63 42 57 43 55 68 46 ... ##  $ bm : num  -1.682 1.363 1.273 -0.68 0.625 ..."},{"path":"/articles/QueryNCP.html","id":"aggregated-query","dir":"Articles","previous_headings":"","what":"Aggregated Query","title":"Distributed Query Count using Non-Cooperating Parties","text":"data aggregated one place, simple query . Let us run sample query aggregated data set condition age < 50 & sex == 'F' & bm < 0.2","code":"do.call(rbind, query_data) %>%     filter(age < 50 & sex == 'F' & bm < 0.2) %>%     nrow() ## [1] 11"},{"path":"/articles/QueryNCP.html","id":"distributed-computation","dir":"Articles","previous_headings":"","what":"Distributed Computation","title":"Distributed Query Count using Non-Cooperating Parties","text":"Assume now data query_data distributed three sites none want share actual data among even master computation process. wish keep data secret willing, together, provide sum total count. wish manner master process unable associate contribution likelihood site. overall query count entire data sum counts site. can count computed preventing master knowing individual contributions site? use two non-cooperating parties, say NCP1 NCP2, accomplish . parties talk , talk sites master process. Site ii sends E(ci+ri)E(c_i + r_i) NCP1 E(ci−ri)E(c_i - r_i) NCP2, cic_i actual count, E(ci)E(c_i) denotes encrypted value cic_i rir_i random quantity generated anew site. NCP1 can compute ∑=13E(ci+ri)\\sum_{=1}^3E(c_i + r_i) NCP2 can compute ∑=13E(ci−ri)\\sum_{=1}^3E(c_i - r_i), individually, neither handle l=∑=13cil = \\sum_{=1}^3 c_i. master process can retrieve ∑=13E(ci+ri)\\sum_{=1}^3E(c_i + r_i) ∑=13E(ci−ri)\\sum_{=1}^3E(c_i - r_i) NCP1 NCP2 respectively. encrypted value sum counts sites, obfuscated random terms, hence random master. However, master using associative homomorphic properties E(.)E(.), can compute: ∑=13E(ci+ri)+∑=13E(ci−ri)=∑=13E(ci+ri+ci−ri)=∑=13E(2ci)=E(2c) \\sum_{=1}^3E(c_i + r_i) +\\sum_{=1}^3E(c_i - r_i) = \\sum_{=1}^3E(c_i + r_i + c_i - r_i)  = \\sum_{=1}^3E(2c_i)  = E(2c) since c=c1+c2+c3c = c_1 + c_2 + c_3 grant total count. master can now decrypt result obtain cc! pictorially shown .  red arrows show master proposing value β\\beta sites, reply back NCP1 NCP2. master retrieves values NCP1 NCP2 sums .","code":""},{"path":"/articles/QueryNCP.html","id":"a-modified-topology","dir":"Articles","previous_headings":"Distributed Computation","what":"A Modified Topology","title":"Distributed Query Count using Non-Cooperating Parties","text":"drawback scheme channels communication established site master process also two non-cooperating parties NCP1 NCP2. number participating sites computation changes, master NCP1 NCP2 made aware change. simpler NCP1 NCP2 can talk master sites. situation arise, example, sites participating disease specific registry. parties NCP1 NCP2 probably set new site onboarded needs known P1 P2. added advantage hiding number sites, even 1! communication topology mean β\\beta values funneled sites NCP1 NCP2 can easily accomplished. picture shows configuration looks complicated actually .  summarize, modified scheme several characteristics: master communicates NCP1 NCP2 NCP1 NCP2 parties communicating master sites NCP1 NCP2 ones know many sites participating New sites can added NCP1 NCP2 need account master remains oblivous number sites; scheme works even one site appears unnecessary communication information, .e. β\\beta sent twice site NCP1 NCP2. easily mitigated engineering either using broker NCP1 NCP2, sites caching results short period avoid recomputation.","code":""},{"path":"/articles/QueryNCP.html","id":"implementation","dir":"Articles","previous_headings":"","what":"Implementation","title":"Distributed Query Count using Non-Cooperating Parties","text":"implementation assumes encryption decryption can happen real numbers actual situation. Instead, use rational approximations using large denominator, 22562^{256}, say. future, course, need build actual library built rigorous algorithms guaranteeing precision overflow/undeflow detection. now, just ad hoc implementation. Also, since using homomorphic additive properties, partial homomorphic scheme Paillier Encryption system sufficient computations. define classes encapsulate sites, non-cooperating parties master process.","code":""},{"path":"/articles/QueryNCP.html","id":"the-site-class","dir":"Articles","previous_headings":"Implementation","what":"The Site Class","title":"Distributed Query Count using Non-Cooperating Parties","text":"site class compute count site data.","code":"Site <-     R6::R6Class(             \"Site\",             private = list(                 ## name of the site                 name = NA,                 ## local data                 data = NA,                 result_cache = NULL,                 filterCondition = NA,                 local_query_count = function() {                     ## Check if value is cached                     result  <- private$result_cache                     if (is.null(result)) {                         ## We need to run the query                         pubkey <- self$pubkey                         ## Generate random offset for int and frac parts                         offset.int <- random.bigz(nBits = 256)                         ## 2. Add to count                         data  <- private$data                         filter_expr  <- eval(parse(text = paste(\"rlang::expr(\", private$filterCondition, \")\")))                         data %>%                             dplyr::filter(!! filter_expr) %>%                             nrow() ->                             result.int                         result  <- list(                             int1 = pubkey$encrypt(result.int - offset.int),                             int2 = pubkey$encrypt(result.int + offset.int)                         )                         private$result_cache  <- result                     }                     result                 }             ),             public = list(                 ## Common denominator for approximate real arithmetic                 den = NA,                 ## The master's public key; everyone has this                 pubkey = NA,                 initialize = function(name, data) {                     private$name <- name                     private$data <- data                 },                 setPublicKey = function(pubkey) {                     self$pubkey <- pubkey                 },                 setDenominator = function(den) {                     self$den = den                 },                 setFilterCondition = function (filterCondition) {                     private$filterCondition  <- filterCondition                 },                 ## query count,                 query_count = function(party) {                     result  <- private$local_query_count()                     if (party == 1) result$int1 else result$int2                 }             )         )"},{"path":"/articles/QueryNCP.html","id":"the-non-cooperating-parties-class","dir":"Articles","previous_headings":"Implementation","what":"The Non-cooperating Parties Class","title":"Distributed Query Count using Non-Cooperating Parties","text":"non-cooperating parties can communicate sites. methods adding sites, passing public keys master etc. query_count method class merely calls site compute result adds sending master, master idea individual contributions.","code":"NCParty <-     R6::R6Class(             \"NCParty\",             private = list(                 ## name of the site                 name = NA,                 ## NC party number                 number = NA,                 ## filter condition                 filterCondition = NA,                 ## The master                 master = NA,                 ## The sites                 sites = list()             ),             public = list(                 ## The master's public key; everyone has this                 pubkey = NA,                 ## The denoinator for rational arithmetic                 den = NA,                 initialize = function(name, number) {                     private$name <- name                     private$number  <- number                 },                 setPublicKey = function(pubkey) {                     self$pubkey <- pubkey                     ## Propagate to sites                     for (site in sites) {                         site$setPublicKey(pubkey)                     }                 },                 setDenominator = function(den) {                     self$den <- den                     ## Propagate to sites                     for (site in sites) {                         site$setDenominator(den)                     }                 },                 setFilterCondition = function(filterCondition) {                     private$filterCondition  <- filterCondition                     ## Propagate to sites                     for (site in sites) {                         site$setFilterCondition(filterCondition)                     }                 },                 addSite = function(site) {                     private$sites  <- c(private$sites, list(site))                 },                 ## sum of all counts                 query_count = function() {                     pubkey  <- self$pubkey                     results  <- lapply(sites, function(x) x$query_count(private$number))                     ## Accumulate the integer and fractional parts                     n  <- length(results)                     enc_sum <- pubkey$encrypt(0)                     for (result in results) {                         enc_sum  <- pubkey$add(enc_sum, result)                     }                     enc_sum                 }             )         )"},{"path":"/articles/QueryNCP.html","id":"the-master-class","dir":"Articles","previous_headings":"Implementation","what":"The Master Class","title":"Distributed Query Count using Non-Cooperating Parties","text":"master process","code":"Master  <-     R6::R6Class(             \"Master\",             private = list(                 ## name of the site                 name = NA,                 ## Private and public keys                 keys = NA,                 ## Non cooperating party 1                 nc_party_1 = NA,                 ## Non cooperating party 2                 nc_party_2 = NA,                 ## filter condition                 filterCondition = NA             ),             public = list(                 ## Denominator for rational arithmetic                 den  = NA,                 initialize = function(name, filterCondition) {                     private$name <- name                     private$keys <- PaillierKeyPair$new(1024) ## Generate new public and private key.                     self$den <- gmp::as.bigq(2)^256  #Our denominator for rational approximations                     private$filterCondition  <- filterCondition                 },                 setNCParty1  = function(site) {                     private$nc_party_1 <- site                     private$nc_party_1$setPublicKey(private$keys$pubkey)                     private$nc_party_1$setDenominator(self$den)                     private$nc_party_1$setFilterCondition(private$filterCondition)                 },                 setNCParty2  = function(site) {                     private$nc_party_2 <- site                     private$nc_party_2$setPublicKey(private$keys$pubkey)                     private$nc_party_2$setDenominator(self$den)                     private$nc_party_2$setFilterCondition(private$filterCondition)                 },                 ## Query count                 query_count = function() {                     pubkey  <- private$keys$pubkey                     privkey  <- private$keys$getPrivateKey()                     result1  <- private$nc_party_1$query_count()                     result2  <- private$nc_party_2$query_count()                     ## Sum it                     enc_sum <- pubkey$add(result1, result2)                     final_result <- as.integer(privkey$decrypt(enc_sum))                     ## Since we 2c, we divide by 2.                     final_result / 2                 }             )         )"},{"path":"/articles/QueryNCP.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Distributed Query Count using Non-Cooperating Parties","text":"now ready use sites computation.","code":""},{"path":"/articles/QueryNCP.html","id":"create-sites","dir":"Articles","previous_headings":"Example","what":"1. Create sites","title":"Distributed Query Count using Non-Cooperating Parties","text":"","code":"site1 <- Site$new(name = \"Site 1\", data = query_data[[1]]) site2 <- Site$new(name = \"Site 2\", data = query_data[[2]]) site3 <- Site$new(name = \"Site 3\", data = query_data[[3]])  sites  <- list(site1 = site1, site2 = site2, site3 = site3)"},{"path":"/articles/QueryNCP.html","id":"create-non-cooperating-parties","dir":"Articles","previous_headings":"Example","what":"2. Create Non-cooperating parties","title":"Distributed Query Count using Non-Cooperating Parties","text":"add sites non-cooperating parties.","code":"ncp1  <- NCParty$new(\"NCP1\", 1) ncp2  <- NCParty$new(\"NCP1\", 2) for (s in sites) {     ncp1$addSite(s)     ncp2$addSite(s) }"},{"path":"/articles/QueryNCP.html","id":"create-the-master-process","dir":"Articles","previous_headings":"Example","what":"3. Create the master process","title":"Distributed Query Count using Non-Cooperating Parties","text":"next connect master non-cooperating parties. point communication graph defined master non-cooperating parties non-cooperating parties sites.","code":"master  <- Master$new(name = \"Master\",                       filterCondition = \"age < 50 & sex == 'F' & bm < 0.2\") master$setNCParty1(ncp1) master$setNCParty2(ncp2)"},{"path":"/articles/QueryNCP.html","id":"perform-the-query","dir":"Articles","previous_headings":"Example","what":"4. Perform the Query","title":"Distributed Query Count using Non-Cooperating Parties","text":"","code":"cat(sprintf(\"Query Count is %d\\n\", master$query_count())) ## Query Count is 11"},{"path":[]},{"path":"/articles/homomorphing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"present toy example homomorphic computation involving maximum likelihood estimation. Consider following data motivated example mle function stats4 R package: wish estimate λ\\lambda, Poisson parameter λ\\lambda randomly generated count data y : function nLL negative log-likelihood data function mle computes maximum likelihood estimate can printed .","code":"library(stats4) set.seed(17822) y <- rpois(n = 40, lambda=10) # Easy one-dimensional MLE: nLL <- function(lambda) -sum(stats::dpois(y, lambda, log = TRUE)) fit0 <- mle(nLL, start = list(lambda = 5), nobs = NROW(y)) summary(fit0) ## Maximum likelihood estimation ##  ## Call: ## mle(minuslogl = nLL, start = list(lambda = 5), nobs = NROW(y)) ##  ## Coefficients: ##        Estimate Std. Error ## lambda    9.175  0.4789311 ##  ## -2 log L: 199.5328 logLik(fit0) ## 'log Lik.' -99.76641 (df=1)"},{"path":"/articles/homomorphing.html","id":"distributed-computation","dir":"Articles","previous_headings":"","what":"Distributed Computation","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"Assume now data y distributed three sites, none want share actual data among even master computation process. wish keep data secret willing, together, provide sum local negative log-likelihoods. need way master process able associate contribution likelihood site. simulate , let’s partition data y follows. overall likelihood function l(λ)l(\\lambda) entire data therefore sum likelihoods site: l(λ)=l1(λ)+l2(λ)+l3(λ).l(\\lambda) = l_1(\\lambda)+l_2(\\lambda)+l_3(\\lambda). can likelihood computed maintaining privacy? Assuming every site including master access homomorphic computation library homomorpheR, likelihood can computed privacy-preserving manner using following scheme. use E(x)E(x) D(x)D(x) denote encrypted decrypted values xx respectively. Master generates public/private key pair. Master distributes public key sites. (private key distributed kept master.) Master generates random offset rr obfuscate intial likelihood. Master sends E(r)E(r) guess λ0\\lambda_0 site 1. Note λ\\lambda encrypted. Site 1 computes l1=l(λ0,y1)l_1 = l(\\lambda_0, y_1), local likelihood local data y1y_1 using parameter λ0\\lambda_0. sends λ0\\lambda_0 E(r)+E(l1)E(r) + E(l_1) site 2. Site 2 computes l2=l(λ0,y2)l_2 = l(\\lambda_0, y_2), local likelihood local data y2y_2 using parameter λ0\\lambda_0. sends λ0\\lambda_0 E(r)+E(l1)+E(l2)E(r) + E(l_1) + E(l_2) site 3. Site 3 computes l3=l(λ0,y3)l_3 = l(\\lambda_0, y_3), local likelihood local data y3y_3 using parameter λ0\\lambda_0. sends E(r)+E(l1)+E(l2)+E(l3)E(r) + E(l_1) + E(l_2) + E(l_3) back master. Master retrieves E(r)+E(l1)+E(l2)+E(l3)E(r) + E(l_1) + E(l_2) + E(l_3) , due homomorphism, exactly E(r+l1+l2+l3)=E(r+l).E(r+l_1+l_2+l_3) = E(r+l). master computes D(E(r+l))−rD(E(r+l)) - r obtain value overall likelihood λ0\\lambda_0. Master updates λ0\\lambda_0 new guess λ1\\lambda_1 repeats steps 1-5. process iterated convergence. added security, even steps 0-5 can repeated, additional computational cost. pictorially shown .","code":"y1 <- y[1:20] y2 <- y[21:27] y3 <- y[28:40]"},{"path":"/articles/homomorphing.html","id":"implementation","dir":"Articles","previous_headings":"","what":"Implementation","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"implementation assumes encryption decryption can happen real numbers actual situation. Instead, use rational approximations using large denominator, 22562^{256}, say. future, course, need build actual library built rigorous algorithms guaranteeing precision overflow/undeflow detection. now, just ad hoc implementation. Also, since using homomorphic additive properties, partial homomorphic scheme Paillier Encryption system sufficient computations. define class encapsulate sites compute Poisson likelihood site data given parameter λ\\lambda. Note addNLLAndForward method takes care split result integer fractional part performing arithmetic operations. (latter approximated rational number.) now ready use sites computation.","code":"library(gmp) library(homomorpheR) Site <- R6::R6Class(\"Site\",                     private = list(                         ## name of the site                         name = NA,                         ## only master has this, NA for workers                         privkey = NA,                         ## local data                         data = NA,                         ## The next site in the communication: NA for master                         nextSite = NA,                         ## is this the master site?                         iAmMaster = FALSE,                         ## intermediate result variable                         intermediateResult = NA                     ),                     public = list(                         ## Common denominator for approximate real arithmetic                         den = NA,                         ## The public key; everyone has this                         pubkey = NA,                         initialize = function(name, data, den) {                             private$name <- name                             private$data <- data                             self$den <- den                         },                         setPublicKey = function(pubkey) {                             self$pubkey <- pubkey                         },                         setPrivateKey = function(privkey) {                             private$privkey <- privkey                         },                         ## Make me master                         makeMeMaster = function() {                             private$iAmMaster <- TRUE                         },                         ## add neg log lik and forward to next site                         addNLLAndForward = function(lambda, enc.offset) {                             if (private$iAmMaster) {                                 ## We are master, so don't forward                                 ## Just store intermediate result and return                                 private$intermediateResult <- enc.offset                             } else {                                 ## We are workers, so add and forward                                 ## add negative log likelihood and forward result to next site                                 ## Note that offset is encrypted                                 nllValue <- self$nLL(lambda)                                 result.int <- floor(nllValue)                                 result.frac <- nllValue - result.int                                 result.fracnum <- as.bigq(numerator(as.bigq(result.frac) * self$den))                                 pubkey <- self$pubkey                                 enc.result.int <- pubkey$encrypt(result.int)                                 enc.result.fracnum <- pubkey$encrypt(result.fracnum)                                 result <- list(int = pubkey$add(enc.result.int, enc.offset$int),                                                frac = pubkey$add(enc.result.fracnum, enc.offset$frac))                                 private$nextSite$addNLLAndForward(lambda, enc.offset = result)                             }                             ## Return a TRUE result for now.                             TRUE                         },                         ## Set the next site in the communication graph                         setNextSite = function(nextSite) {                             private$nextSite <- nextSite                         },                         ## The negative log likelihood                         nLL = function(lambda) {                             if (private$iAmMaster) {                                 ## We're master, so need to get result from sites                                 ## 1. Generate a random offset and encrypt it                                 pubkey <- self$pubkey                                 offset <- list(int = random.bigz(nBits = 256),                                                frac = random.bigz(nBits = 256))                                 enc.offset <- list(int = pubkey$encrypt(offset$int),                                                    frac = pubkey$encrypt(offset$frac))                                 ## 2. Send off to next site                                 throwaway <- private$nextSite$addNLLAndForward(lambda, enc.offset)                                 ## 3. When the call returns, the result will be in                                 ##    the field intermediateResult, so decrypt that.                                 sum <- private$intermediateResult                                 privkey <- private$privkey                                 intResult <- as.double(privkey$decrypt(sum$int) - offset$int)                                 fracResult <- as.double(as.bigq(privkey$decrypt(sum$frac) - offset$frac) / den)                                 intResult + fracResult                             } else {                                 ## We're worker, so compute local nLL                                 -sum(stats::dpois(private$data, lambda, log = TRUE))                             }                         })                     )"},{"path":"/articles/homomorphing.html","id":"generate-public-and-private-key-pair","dir":"Articles","previous_headings":"Implementation","what":"1. Generate public and private key pair","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"also choose denominator rational approximations.","code":"keys <- PaillierKeyPair$new(1024) ## Generate new public and private key. den <- gmp::as.bigq(2)^256  #Our denominator for rational approximations"},{"path":"/articles/homomorphing.html","id":"create-sites","dir":"Articles","previous_headings":"Implementation","what":"2. Create sites","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"master process also site data. thus designated.","code":"site1 <- Site$new(name = \"Site 1\", data = y1, den = den) site2 <- Site$new(name = \"Site 2\", data = y2, den = den) site3 <- Site$new(name = \"Site 3\", data = y3, den = den) ## Master has no data! master <- Site$new(name = \"Master\", data = c(), den = den) master$makeMeMaster()"},{"path":"/articles/homomorphing.html","id":"distribute-public-key-to-sites","dir":"Articles","previous_headings":"Implementation","what":"2. Distribute public key to sites","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"master private key decryption.","code":"site1$setPublicKey(keys$pubkey) site2$setPublicKey(keys$pubkey) site3$setPublicKey(keys$pubkey) master$setPublicKey(keys$pubkey) master$setPrivateKey(keys$getPrivateKey())"},{"path":"/articles/homomorphing.html","id":"define-the-communication-graph","dir":"Articles","previous_headings":"Implementation","what":"3. Define the communication graph","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"Master always send first site, others forward results turn last site returning master.","code":"master$setNextSite(site1) site1$setNextSite(site2) site2$setNextSite(site3) site3$setNextSite(master)"},{"path":"/articles/homomorphing.html","id":"perform-the-likelihood-estimation","dir":"Articles","previous_headings":"Implementation","what":"4. Perform the likelihood estimation","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"Print summary. results .","code":"fit1 <- mle(master$nLL, start = list(lambda = 5)) summary(fit1) ## Maximum likelihood estimation ##  ## Call: ## mle(minuslogl = master$nLL, start = list(lambda = 5)) ##  ## Coefficients: ##        Estimate Std. Error ## lambda    9.175  0.4789311 ##  ## -2 log L: 199.5328 logLik(fit1) ## 'log Lik.' -99.76641 (df=1)"},{"path":"/articles/homomorphing.html","id":"applications-via-distcomp-and-opencpu","dir":"Articles","previous_headings":"","what":"Applications via distcomp and opencpu","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"One can imagine sort computations constructed within framework described R package distcomp sites opencpu servers master process executing computation. Much work remains done make work seamless manner; however, proof--concept example shows, technical hurdles quite surmountable.","code":""},{"path":"/articles/homomorphing.html","id":"caveat","dir":"Articles","previous_headings":"","what":"CAVEAT","title":"Maximum Likelihood Computation using Homomorphic Computation","text":"initial proof--concept implementation substantially improved real-world use. ’ve warned.","code":""},{"path":"/articles/introduction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to Homomorphic Computation in R","text":"homomorphism structure-preserving map one algebraic structure another; see Wikipedia. Privacy experts interested homomorphic computation offers way perform computations encrypted data, either distributed setting cloud, thereby handling many headaches associated storing/moving/anonymizing data. Homomorphic computation also finds application secure voting, verifyable computing, secure multi-party computation, etc. homomorphic encryption scheme one provides homomorphism along infrastructure carry computations. schemes provide algorithms generating public private keys. public key distributed anyone private key needed one decryption. several schemes documented Wikipedia. main thing know two flavours: partial full. Partial schemes preserve structure certain specified operations, say addition , whereas full schemes standard arithmetic operations. operations mentioned context algebraic structure underneath, purposes modular arithmetic modulus large number. current package homomorpheR implements Paillier system partially homomorphic; provides additive homomorphism. implementation borrows much Javascript implementation proof--concept system. Therefore, yet ready serious work. , ’ve warned. interested mathematical details Paillier crytosystem, main reference (Paillier 1999). Volkhausen (2006) provides detailed mathematical introduction; Michael O’Keefe (2008) gentler one. simple application Paillier system secure vote tallying (Choinyammbu 2009). bit notation helps. Let xx message; us, just large integer. Denote E(x)E(x) encrypted message D(x)D(x) decryption xx scheme. scheme homomorphic addition, E(x)+E(y)=E(x+y). E(x) + E(y) = E(x + y). means calculating x+yx+y can done decrypting sum encrypted values xx yy. Thus, entities need exchange encrypted values throughout. pictorially shown figure (source: Jeremy Kun) :","code":""},{"path":"/articles/introduction.html","id":"facilities","dir":"Articles","previous_headings":"","what":"Facilities","title":"Introduction to Homomorphic Computation in R","text":"first step, public private key pair needs generated. generating bits cryptosystems, secure random number source needed; homomorpheR makes use R package sodium Jeroen Ooms (based Daniel J. Bernstein’s generators) addition gmp arbitrary precision arithmetic. Examine keyPair object: pubkey field can distributed interested parties private key, obtainable getPrivateKey() kept secret decryption. main functions encrypt function public key, decrypt function private key.","code":"library(homomorpheR) keyPair <- PaillierKeyPair$new(modulusBits = 1024) keyPair ## <PaillierKeyPair> ##   Public: ##     clone: function (deep = FALSE)  ##     getPrivateKey: function ()  ##     initialize: function (modulusBits)  ##     pubkey: PaillierPublicKey, R6 ##   Private: ##     privkey: PaillierPrivateKey, R6"},{"path":"/articles/introduction.html","id":"some-tests","dir":"Articles","previous_headings":"","what":"Some tests","title":"Introduction to Homomorphic Computation in R","text":"can now perform simple tests. simple function encrypts decrypts. Now can encrypt decrypt numbers. Now large set numbers. function random.bigz returns large random numbers.","code":"encryptAndDecrypt <- function(x) keyPair$getPrivateKey()$decrypt(keyPair$pubkey$encrypt(x)) a <- gmp::as.bigz(1273849) identical(a + 10, encryptAndDecrypt(a + 10)) ## [1] TRUE m <- lapply(1:100, function(x) random.bigz(nBits = 512)) md <- lapply(m, encryptAndDecrypt) identical(m, md) ## [1] TRUE"},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Balasubramanian Narasimhan. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Narasimhan B (2025). homomorpheR: Homomorphic Computations R. R package version 0.3, https://bnaras.github.io/homomorpheR.","code":"@Manual{,   title = {homomorpheR: Homomorphic Computations in R},   author = {Balasubramanian Narasimhan},   year = {2025},   note = {R package version 0.3},   url = {https://bnaras.github.io/homomorpheR}, }"},{"path":"/index.html","id":"homomorpher","dir":"","previous_headings":"","what":"Homomorphic Computations in R","title":"Homomorphic Computations in R","text":"published version may found CRAN can installed usual.","code":""},{"path":"/index.html","id":"development-version","dir":"","previous_headings":"","what":"Development version","title":"Homomorphic Computations in R","text":"Install development version cutting pasting R session, install dependencies also. Four vignettes provided: quick easy introduction homomorphic computations, example Homomorphic Maximum Likelihood Estimation Poisson parameter, Fitting Stratified Cox Regression model data distributed across sites, example Query Count using Noncooperating parties, Fitting Stratified Cox Regression model data distributed across sites using Non-cooperating parties. related project distcomp.","code":"## Install a package if not already installed install_if_needed <- function(packages, ...) {     toInstall <- setdiff(packages, installed.packages()[, 1])     if (length(toInstall) > 0) install.packages(toInstall, ...) } install_if_needed(c(\"gmp\", \"sodium\", \"devtools\"), repos = \"https://cloud.r-project.org\") devtools::install_github(\"bnaras/homomorpheR\")"},{"path":"/index.html","id":"website","dir":"","previous_headings":"","what":"Website","title":"Homomorphic Computations in R","text":"can view everything, including documentation vignettes homomorpheR website.","code":""},{"path":"/reference/PaillierKeyPair.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"Construct Paillier public private key pair given fixed number bits Construct Paillier public private key pair given fixed number bits","code":""},{"path":"/reference/PaillierKeyPair.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"R6::R6Class() generator object","code":""},{"path":"/reference/PaillierKeyPair.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"PaillierKeyPair$getPrivateKey() Return private key","code":""},{"path":[]},{"path":"/reference/PaillierKeyPair.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"pubkey public key","code":""},{"path":[]},{"path":"/reference/PaillierKeyPair.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"PaillierKeyPair$new() PaillierKeyPair$getPrivateKey() PaillierKeyPair$clone()","code":""},{"path":"/reference/PaillierKeyPair.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"Create new public private key pair specified number modulus bits","code":""},{"path":"/reference/PaillierKeyPair.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"","code":"PaillierKeyPair$new(modulusBits)"},{"path":"/reference/PaillierKeyPair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"modulusBits number bits use","code":""},{"path":"/reference/PaillierKeyPair.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"PaillierKeyPair object","code":""},{"path":"/reference/PaillierKeyPair.html","id":"method-getprivatekey-","dir":"Reference","previous_headings":"","what":"Method getPrivateKey()","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"Return private key","code":""},{"path":"/reference/PaillierKeyPair.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"","code":"PaillierKeyPair$getPrivateKey()"},{"path":"/reference/PaillierKeyPair.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"private key","code":""},{"path":"/reference/PaillierKeyPair.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"objects class cloneable method.","code":""},{"path":"/reference/PaillierKeyPair.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"","code":"PaillierKeyPair$clone(deep = FALSE)"},{"path":"/reference/PaillierKeyPair.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"deep Whether make deep clone.","code":""},{"path":"/reference/PaillierKeyPair.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a Paillier public and private key pair given a fixed number of bits — PaillierKeyPair","text":"","code":"keys <- PaillierKeyPair$new(1024) keys$pubkey #> <PaillierPublicKey> #>   Public: #>     add: function (a, b)  #>     add_real: function (den, a, b)  #>     bits: 1024 #>     clone: function (deep = FALSE)  #>     encrypt: function (m)  #>     initialize: function (bits, n)  #>     mult: function (a, b)  #>     n: 13513891455470442392728615117337774955015770408059685429 ... #>     nPlusOne: 13513891455470442392728615117337774955015770408059685429 ... #>     nSquared: 18262526227023703188755128798122578316842762524824305454 ... #>     sub: function (a, b)  #>     sub_real: function (den, a, b)  #>   Private: #>     randomize: function (a)  keys$getPrivateKey() #> <PaillierPrivateKey> #>   Public: #>     clone: function (deep = FALSE)  #>     decrypt: function (c)  #>     getLambda: function ()  #>     initialize: function (lambda, pubkey)  #>     pubkey: PaillierPublicKey, R6 #>   Private: #>     lambda: 67569457277352211963643075586688874775078852040298427149 ... #>     x: 10467730736249515472776798664340932798070920882170095764 ..."},{"path":"/reference/PaillierPrivateKey.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"Construct Paillier private key given secret public key Construct Paillier private key given secret public key","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"R6::R6Class() generator object","code":""},{"path":[]},{"path":"/reference/PaillierPrivateKey.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"pubkey public key","code":""},{"path":[]},{"path":"/reference/PaillierPrivateKey.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"PaillierPrivateKey$new() PaillierPrivateKey$getLambda() PaillierPrivateKey$decrypt() PaillierPrivateKey$clone()","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"Create new private key given secret lambda public key","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"","code":"PaillierPrivateKey$new(lambda, pubkey)"},{"path":"/reference/PaillierPrivateKey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"lambda secret pubkey public key","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"method-getlambda-","dir":"Reference","previous_headings":"","what":"Method getLambda()","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"Return secret lambda","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"","code":"PaillierPrivateKey$getLambda()"},{"path":"/reference/PaillierPrivateKey.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"lambda","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"method-decrypt-","dir":"Reference","previous_headings":"","what":"Method decrypt()","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"Decrypt message","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"","code":"PaillierPrivateKey$decrypt(c)"},{"path":"/reference/PaillierPrivateKey.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"c message","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"decrypted message","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"objects class cloneable method.","code":""},{"path":"/reference/PaillierPrivateKey.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"","code":"PaillierPrivateKey$clone(deep = FALSE)"},{"path":"/reference/PaillierPrivateKey.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier private key with the given secret and a public key — PaillierPrivateKey","text":"deep Whether make deep clone.","code":""},{"path":"/reference/PaillierPublicKey.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"Construct Paillier public key given modulus. Construct Paillier public key given modulus.","code":""},{"path":"/reference/PaillierPublicKey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"R6::R6Class() generator object","code":""},{"path":[]},{"path":"/reference/PaillierPublicKey.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"bits number bits modulus n modulus nSquared square modulus nPlusOne one modulus","code":""},{"path":[]},{"path":"/reference/PaillierPublicKey.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"PaillierPublicKey$new() PaillierPublicKey$encrypt() PaillierPublicKey$add() PaillierPublicKey$sub() PaillierPublicKey$add_real() PaillierPublicKey$sub_real() PaillierPublicKey$mult() PaillierPublicKey$clone()","code":""},{"path":"/reference/PaillierPublicKey.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"Create new public key precompute internal values efficiency","code":""},{"path":"/reference/PaillierPublicKey.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"","code":"PaillierPublicKey$new(bits, n)"},{"path":"/reference/PaillierPublicKey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"bits number bits use n modulus use","code":""},{"path":"/reference/PaillierPublicKey.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"new PaillierPublicKey object","code":""},{"path":"/reference/PaillierPublicKey.html","id":"method-encrypt-","dir":"Reference","previous_headings":"","what":"Method encrypt()","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"Encrypt message","code":""},{"path":"/reference/PaillierPublicKey.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"","code":"PaillierPublicKey$encrypt(m)"},{"path":"/reference/PaillierPublicKey.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"m message","code":""},{"path":"/reference/PaillierPublicKey.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"encrypted message","code":""},{"path":"/reference/PaillierPublicKey.html","id":"method-add-","dir":"Reference","previous_headings":"","what":"Method add()","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"Add two encrypted messages","code":""},{"path":"/reference/PaillierPublicKey.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"","code":"PaillierPublicKey$add(a, b)"},{"path":"/reference/PaillierPublicKey.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"message b another message","code":""},{"path":"/reference/PaillierPublicKey.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"sum b","code":""},{"path":"/reference/PaillierPublicKey.html","id":"method-sub-","dir":"Reference","previous_headings":"","what":"Method sub()","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"Subtract one encrypted message another","code":""},{"path":"/reference/PaillierPublicKey.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"","code":"PaillierPublicKey$sub(a, b)"},{"path":"/reference/PaillierPublicKey.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"message b another message","code":""},{"path":"/reference/PaillierPublicKey.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"difference - b","code":""},{"path":"/reference/PaillierPublicKey.html","id":"method-add-real-","dir":"Reference","previous_headings":"","what":"Method add_real()","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"Return sum + b encrypted real message , list consisting encrypted integer part (named int) encrypted fractional part (named frac), real number using den denominator rational approximation.","code":""},{"path":"/reference/PaillierPublicKey.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"","code":"PaillierPublicKey$add_real(den, a, b)"},{"path":"/reference/PaillierPublicKey.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"den denominator use rational approximations real message, list consisting integer fractional parts named int frac respectively b simple real number","code":""},{"path":"/reference/PaillierPublicKey.html","id":"method-sub-real-","dir":"Reference","previous_headings":"","what":"Method sub_real()","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"Return difference - b encrypted real message , list consisting encrypted integer part (named int) encrypted fractional part (named frac), real number b using den denominator rational approximation.","code":""},{"path":"/reference/PaillierPublicKey.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"","code":"PaillierPublicKey$sub_real(den, a, b)"},{"path":"/reference/PaillierPublicKey.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"den denominator use rational approximations real message, list consisting integer fractional parts named int frac respectively b simple real number","code":""},{"path":"/reference/PaillierPublicKey.html","id":"method-mult-","dir":"Reference","previous_headings":"","what":"Method mult()","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"Return product two encrypted messages b","code":""},{"path":"/reference/PaillierPublicKey.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"","code":"PaillierPublicKey$mult(a, b)"},{"path":"/reference/PaillierPublicKey.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"message b another message","code":""},{"path":"/reference/PaillierPublicKey.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"product b","code":""},{"path":"/reference/PaillierPublicKey.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"objects class cloneable method.","code":""},{"path":"/reference/PaillierPublicKey.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"","code":"PaillierPublicKey$clone(deep = FALSE)"},{"path":"/reference/PaillierPublicKey.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Paillier public key with the given modulus. — PaillierPublicKey","text":"deep Whether make deep clone.","code":""},{"path":"/reference/homomorpheR.html","id":null,"dir":"Reference","previous_headings":"","what":"homomorpheR: Homomorphic computations in R — homomorpheR","title":"homomorpheR: Homomorphic computations in R — homomorpheR","text":"homomorpheR start rudimentary package homomorphic computations R. goal collect homomorphic encryption schemes package privacy-preserving distributed computations; example, applications sort immplemented package distcomp.","code":""},{"path":"/reference/homomorpheR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"homomorpheR: Homomorphic computations in R — homomorpheR","text":"moment, one scheme implemented, Paillier scheme. current implementation makes pretense efficiency also uses direct translations implementations, particularly one Javascript. quick overview features, refer vignettes package.","code":""},{"path":"/reference/homomorpheR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"homomorpheR: Homomorphic computations in R — homomorpheR","text":"Homomorphic Encryyption Paillier Encryption","code":""},{"path":[]},{"path":"/reference/homomorpheR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"homomorpheR: Homomorphic computations in R — homomorpheR","text":"Maintainer: Balasubramanian Narasimhan naras@stat.Stanford.EDU","code":""},{"path":"/reference/homomorpheR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"homomorpheR: Homomorphic computations in R — homomorpheR","text":"","code":"keys <- PaillierKeyPair$new(1024) # Generate new key pair encryptAndDecrypt <- function(x) keys$getPrivateKey()$decrypt(keys$pubkey$encrypt(x)) a <- gmp::as.bigz(1273849) identical(a + 10L, encryptAndDecrypt(a+10L)) #> [1] TRUE x <- lapply(1:100, function(x) random.bigz(nBits = 512)) edx <- lapply(x, encryptAndDecrypt) identical(x, edx) #> [1] TRUE"},{"path":"/reference/random.bigz.html","id":null,"dir":"Reference","previous_headings":"","what":"Return a random big number using the cryptographically secure random number generator from in the sodium package. — random.bigz","title":"Return a random big number using the cryptographically secure random number generator from in the sodium package. — random.bigz","text":"Return random big number using cryptographically secure random number generator sodium package.","code":""},{"path":"/reference/random.bigz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return a random big number using the cryptographically secure random number generator from in the sodium package. — random.bigz","text":"","code":"random.bigz(nBits)"},{"path":"/reference/random.bigz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return a random big number using the cryptographically secure random number generator from in the sodium package. — random.bigz","text":"nBits, number bits, must multiple 8, checked efficiency.","code":""},{"path":"/news/index.html","id":"version-03","dir":"Changelog","previous_headings":"","what":"Version 0.3","title":"Version 0.3","text":"Added MPC vignettes","code":""}]
